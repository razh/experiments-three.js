/* eslint-env es6 */

_1 = 2
_2 = 2 * _1
_3 = 3 * _1
_4 = 4 * _1
_5 = 5 * _1
_z = _1

// intercept transforms
nx_py = align('nx_py')

a = (geometry, ...transforms) => _(geometry, nx_py, ...transforms)

A = $$([
  a([_1, _5, _z]),
  a([_1, _1, _z], tx(_1)),
  a([_1, _1, _z], tx(_1), ty(-_2)),
  a([_1, _5, _z], tx(_2)),
])

B = $$([
  a([_1, _5, _z]),
  a([_2, _1, _z], tx(_1)),
  a([_1, _1, _z], tx(_2), ty(-_1)),
  a([_1, _1, _z], tx(_1), ty(-_2)),
  a([_1, _1, _z], tx(_2), ty(-_3)),
  a([_2, _1, _z], tx(_1), ty(-_4)),
])

C = $$([
  a([_1, _3, _z], ty(-_1)),
  a([_2, _1, _z], tx(_1)),
  a([_2, _1, _z], tx(_1), ty(-_4)),
])

D = $$([
  a([_1, _5, _z]),
  a([_1, _1, _z], tx(_1)),
  a([_1, _1, _z], tx(_1), ty(-_4)),
  a([_1, _4, _z], tx(_2), ty(-_1)),
])

E = $$([
  a([_1, _5, _z]),
  a([_2, _1, _z], tx(_1)),
  a([_1, _1, _z], tx(_1), ty(-_2)),
  a([_2, _1, _z], tx(_1), ty(-_4)),
])

F = $$([
  a([_1, _5, _z]),
  a([_2, _1, _z], tx(_1)),
  a([_1, _1, _z], tx(_1), ty(-_2)),
])

G = $$([
  a([_1, _4, _z], ty(-_1)),
  a([_2, _1, _z], tx(_1)),
  a([_1, _1, _z], tx(_2), ty(-_3)),
  a([_2, _1, _z], tx(_1), ty(-_4)),
])

H = $$([
  a([_1, _5, _z]),
  a([_1, _1, _z], tx(_1), ty(-_2)),
  a([_1, _5, _z], tx(_2)),
])

I = $$([
  a([_3, _1, _z]),
  a([_1, _3, _z], tx(_1), ty(-_1)),
  a([_3, _1, _z], ty(-_4)),
])

J = $$([
  a([_3, _1, _z]),
  a([_1, _4, _z], tx(_1), ty(-_1)),
  a([_1, _1, _z], ty(-_4)),
])

K = $$([
  a([_1, _5, _z]),
  a([_1, _2, _z], tx(_2)),
  a([_1, _1, _z], tx(_1), ty(-_2)),
  a([_1, _2, _z], tx(_2), ty(-_3)),
])

L = $$([
  a([_1, _5, _z]),
  a([_2, _1, _z], tx(_1), ty(-_4)),
])

M = $$([
  a([_1, _5, _z]),
  a([_1, _2, _z], tx(_1)),
  a([_1, _5, _z], tx(_2)),
])

return [
  A,
  B,
  C,
  D,
  E,
  F,
  G,
  H,
  I,
  J,
  K,
  L,
  M,
].map((geometry, index) => _(geometry, tx(_4 * index), ty(_5)))
