/* global THREE */
/* exported drawGear */
const drawGear = (function() {
  'use strict';

  function lineTo( ctx, radius, angle ) {
    const cos = Math.cos( angle );
    const sin = Math.sin( angle );
    ctx.lineTo( cos * radius, sin * radius );
  }

  /*
    segment
    ===

      startAngle   endAngle
          o-----------o
           \         /
            \       /  radius
             \     /
              \   /
                o
             (0, 0)

    tooth
    ===

             0.4   0.6
      r'       o---o
              /     \
      r  o---o       o---o
         0  0.2     0.8  1

    This can be represented as:

      [
        [ 0.0, r  ], // implicit start point
        [ 0.2, r  ],
        [ 0.4, r' ],
        [ 0.6, r' ],
        [ 0.8, r  ],
        [ 1.0, r  ] // implicit end point
      ]

    Note that the start and end points are implicitly defined at the
    baseline radius.
   */

  /**
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} radius
   * @param {number} segments
   * @param {Array<Array<number>>} tooth - Array of tuples: [ parameter, radius ].
   */
  function drawGear( ctx, radius = 50, segments = 8, tooth = [] ) {
    segments = Math.max( 3, segments );

    const segmentAngle = 2 * Math.PI / segments;

    ctx.moveTo( radius, 0 );

    for ( let i = 0; i < segments; i++ ) {
      const startAngle = i * segmentAngle;
      const endAngle = ( i + 1 ) * segmentAngle;

      tooth.forEach( point => {
        const angle = THREE.Math.mapLinear( point[0], 0, 1, startAngle, endAngle );
        lineTo( ctx, point[1], angle );
      });

      // When closing a path, lineTo() will cause THREE.Shape.prototype.extractPoints()
      // to generate a duplicate of the initial point. Prefer closePath() instead.
      if ( i < segments - 1 ) {
        lineTo( ctx, radius, endAngle );
      }
    }

    ctx.closePath();

    return ctx;
  }

  drawGear.lineTo = lineTo;

  return drawGear;
}());

/* exported drawLineCurveCircle */
const drawLineCurveCircle = (function() {
  'use strict';

  /*
    Create a circle with a given number of LineCurves.

    THREE.Shape#absarc() uses THREE.EllipseCurve, which does not offer control
    over the number of segments generated by THREE.CurvePath#getPoints().
   */
  return function drawLineCurveCircle( ctx, radius = 50, segments = 8 ) {
    segments = Math.max( 3, segments );

    const segmentAngle = 2 * Math.PI / segments;

    ctx.moveTo( radius, 0 );

    for ( let i = 0; i < segments; i++ ) {
      const angle = ( i + 1 ) * segmentAngle;

      if ( i < segments - 1 ) {
        drawGear.lineTo( ctx, radius, angle );
      }
    }

    ctx.closePath();

    return ctx;
  };
}());
